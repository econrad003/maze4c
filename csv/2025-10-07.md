# Degree Sequences - 7 October 2025

## Introduction

In this experiment, the degree sequences and diameters produced by a given algorithm were averaged over 100 runs for each of a number of maze algorithms.  Means and standard deviations were calculated for each algorithm.

Each mazes in the experiment was a perfect maze (*i.e.* a spanning tree) on a 21×34 rectangular grid with Von Neumann neighborhoods (*i.e.* up to 4 neighbors in the principal compass directions - type *OblongGrid(21, 34)).

The pseudorandom number generator used to produce the mazes was the native Python (v3.12) *random* module.  The Mersenne twister implementation reportedly avoids poor distribution in two dimensions.

The Python program used to create the CSV is located in the *stats* folder.

## The basics

Rows are grouped in pairs.  The first row in a pair consists of means (averages) while the second contains standard deviations.  The standard deviation corresponds very roughly to error or noise in the data.  For our analysis, we will naively *assume* that the population mean is very likely to be somewhere within one standard deviation of the sample mean.

(We won't actually say what we mean by "*very likely*".  With real statistical research, we would repeat the experiment, possibly with larger sample sizes, and we would attach confidence intervals.  Take any conclusions drawn here with a grain of salt.)

## Columns and entries with no variance

The following columns had a standard deviation of 0 and identical averages for all samples:

* isolated cells
* degree sum
* cells
* edges
* arcs

Since all the sampled methods produce perfect mazes, we expect the results to be identical, not only within each sample, but also from sample to sample.

Each grid in all the samples had 21 rows and 34 columns giving a total of 714 cells.  For a spanning tree, then we must have 713 two-way passages (edges) and no one-way passages (arcs).  If there are no arcs, the sum of the degrees of the vertices (degree sum) must be twice the number of edges or 1426.

If there happened to be an isolated cell (or equivalently a degree-0 cell), then the maze, having more than one cell, would be disconnected.  In that case it would not be a tree.  All the mazes contained more than one cell, so an isolated cell would indicate a problem with either the algorithm or its implementation.

There was, in addition, one column which had one entry with no variance -- the (simple) binary tree row showed a constant value of 0 for the number of degree-4 cells.  The cells in a binary tree must have degree 1, 2 or 3.  In fact, any tree whose cells have degree at most 3 is a binary tree -- and any cell of degree 1 or 2 in such a tree can be taken as its root.

## Dead ends

A dead end is a degree-1 cell.  The only exit from the cell is to turn back.  If we sort the algorithms our samples in descending order by the number of dead ends, we have the following table (algorithm, mean dead ends, standard deviation):
```
Prim/Vertex                       316.240   5.906
Kruskal                           216.870   7.664  **
Prim                              216.150   7.624  **
MT Random Walk/3 tasks            212.990   7.785
Houston                           211.610   7.302
MT Random Walk/2 tasks            211.270   7.824
Inwinder                          210.920   7.341
Wilson                            208.440   7.250  *
Aldous/Broder                     207.800   6.854  *
Eller                             205.440   7.427
Outward Eller                     204.250   7.283
Prim/Simplified                   197.560   7.840
Sidewinder                        195.800   6.806
Outwinder                         195.520   6.992
Recursive Division                195.460   7.881
Binary Tree/Simple                178.850   6.467
Breadth-first forest/3 tasks      102.110  12.323
Breadth-first forest/2 tasks       85.930  11.486
Hunt & Kill                        81.470   5.825
Depth-first forest/3 tasks         75.490   5.495
Depth-first forest/2 tasks         75.330   5.004
Depth-first search                 74.420   5.171
Breadth-first search               59.890  13.383
```

In this sampling, vertex-Prim produces the largest number of dead ends -- 31,624 dead ends total in all 100 samples, for a sample mean of 316.24 dead ends.  The low variance -- variance is the square of the standard deviation -- indicates that results didn't vary greatly from the average.

(In a normal distribution, about 2/3 of the area lies within one standard deviation.  For distributions that aren't normal, Chebyshev's inequality provides some error bounds.)

Kruskals' algorithm and Prim's algorithm (both of which generate minimum weight spanning trees) were close to each other, generating an average between 216 and 217 with a standard deviation close to 8.  If the results reflect a normal distribution, we might guess that about 2/3 of minimun weight spanning trees on a 21 by 34 Von Neumann grid have between about 209 and about 225 dead ends.  (From just one sample, that conclusion is a stretch.)

Notice that Wilson's Algorithm and Aldous/Broder were close, averaging about 208 with standard deviations of about 7.  An ideal implementation of either one produces "uniform spanning trees".  (Every possible spanning tree is output with equal probability.)  A real-world implementation using a pseudorandom generator will always fall short given a sufficiently large grid.

The spider web mazes produced by breadth-first search produced the fewest dead ends, albeit with a large variance.  The variance can easily be explained -- the results depend heavily on the location of the starting cell.

Depth-first search and the two variants (depth-first forest with 2 and 3 tasks) were on the low end of the spectrum (with low variance) and the average for Hunt and Kill was about one standard larger.

## Degree-2 and Degree-3 cells

I don't plan to take a closer look at the results for these two columns.  Naturally, I reserve the right to change my mind.

## Degree-4 cells

Before I show the sorted results for the samples, let me pose a problem...  I won't answer this one, but it's worth giving it some thought.

### How many degree-4 can a rectangular maze have?

If there are no cells of degree greater than 3, then a tree is binary.  How close do other algorithms come?  It probably depends on the grid.  *OblongGrid(21,34)* has 19×32=608 cells having all four possible grid connections. But for a spanning tree, the sum of the degrees must be twice the number of passages or 2×713=1426.  How many degree 4 cells can we have in this situation?  Finding an answer is harder that you might think.  We have to avoid cycles.  The simplest configuration with a cycle is a 2×2 square:
```
              +   +   +
                A   B
              +   +   +
                D   C
              +   +   +
```
Here the four cells form a circuit:  A -- B -- C -- D -- A.  One of those passages has to be walled, for example CD.  But what about the cells above A and B, or to the left of A and D, or to the right of B and C?
```
              +   +   +

          +   +   +   +   +
                A   B
          +   +   +   +   +
                D | C
          +   +   +   +   +
```
How many walls do we need to place to get a perfect maze?
```
          sum of grid-edge degrees:
                       19×32 = 608      times 4:    2432
                   2×(19+32) = 102      times 3:     306
                                 4      times 2:       8
                              -----                ------
                               714 cells            2746 degree sum

          number of grid edges           2746 / 2 = 1373
          number of passages (spanning tree)         713
                            (subtract)             ------
          number of walls (spanning tree)            660
```
So we need to place 660 walls -- without disconnecting the maze AND without leaving any circuits.  (An algorithm that creates a maze by walling off passages is called a wall-builder. The algorithms sampled here are all passage carvers.)

And as I said, I won't answer the question.

### Results for degree-4 cells

Here are the results for the samples:
```
Prim/Vertex                     75.960  5.41
Kruskal                         28.170  3.718  **
Prim                            27.190  4.959  **
MT Random Walk/2 tasks          25.650  4.586
Inwinder                        25.240  3.847
MT Random Walk/3 tasks          25.230  4.636
Houston                         25.060  4.481
Wilson                          24.290  4.201  *
Eller                           23.890  4.456
Aldous/Broder                   23.710  4.162  *
Outward Eller                   22.070  4.290
Recursive Division              19.240  4.092
Prim/Simplified                 18.270  3.679
Sidewinder                      17.670  3.622
Outwinder                       13.550  3.051
Breadth-first forest/3 tasks     7.720  2.616
Breadth-first forest/2 tasks     4.660  1.733
Hunt & Kill                      2.510  1.507
Breadth-first search             2.490  1.493
Depth-first forest/2 tasks       1.270  0.999
Depth-first forest/3 tasks       1.260  0.945
Depth-first search               1.160  1.074
Binary Tree/Simple               0.000  0.000
```

The two minimum weight spanning tree algorithms (Kruskal and Prim) we nearly tied.  Likewise, the two uniform spanning tree algorithms were nearly tied.

Vertex-Prim, which produced a lot of dead ends, compensated for them with a lot of 4-way intersections.

DFS, BFS, and Hunt and Kill produced very few degree-4 nodes.  But for BFS, the situation is fairly clear.  If BFS starts in the interior, BFS guarantees that the starting cell will be degree 4.  If it starts on the perimeter, the starting cell can't and won't be degree-4.  BFS may produce an occasional degree-4 cell as it sends its feelers out from the starting point.  DFS does often produce binary trees on a rectangular maze (no degree-4 cells).

A degree-4 node in binary tree algorithm implementation signals a bug.  Fortunately our simple binary tree algorithm saw no such nonsense.

## Diameter

The diameter of a connected maze is the length of a longest path.  In general, this is a hard problem (NP-complete), but it is straightforward to solve when the maze is a tree.  Here are the statistics:
```
Depth-first search               375.930  40.689
Depth-first forest/2 tasks       338.450  45.714
Depth-first forest/3 tasks       316.340  47.580
Hunt & Kill                      212.700  32.619
Outward Eller                    168.490  16.694
Recursive Division               147.320  23.506
Aldous/Broder                    134.080  20.598  *
MT Random Walk/3 tasks           133.730  20.046
Wilson                           133.160  18.288  *
MT Random Walk/2 tasks           130.870  19.370
Eller                            130.490  17.496
Houston                          129.300  19.722
Outwinder                        128.750   6.731
Prim                             120.990  16.588  **
Kruskal                          120.450  16.614  **
Prim/Vertex                      104.180  13.857
Sidewinder                       102.950   7.076
Binary Tree/Simple                94.800   4.537
Breadth-first forest/3 tasks      94.350  17.119
Breadth-first forest/2 tasks      85.370  14.573
Prim/Simplified                   79.210  11.331
Breadth-first search              72.330   7.742
Inwinder                          63.640   3.732
```
The mean and standard deviation were nearly tied for the uniform spanning tree algoithms (Aldous/Broder and Wilson.  A near-tie occured for the minimum weight spanning tree algorithms (Kruskal and Prim).

Depth-first search topped the diameters with a diameter of about 376, but with an error (standard deviation) of roughly 10%.

The tiniest mazes were produced by inwinder (diameter 64, error about 5%) and BFS (diameter 73, error about 10%)

## OPEN-ENDED EXERCISES

1. Add your own speculations to give a partial answer to the question "How many degree-4 cells can a perfect maze on rectangular 4-grid have?"  Is this an open problem or is there a satisfactory answer?  Is there an algorithm for producing such a maze?
2. Produce sorted tables for the degree-2 and degree-3 cases.  Briefly analyze the results.
3. Rerun the experiment and compare your data with my data.
4. Compare my results with similar results (for a different grid size!) based on experiments documented in the Jamis Buck book.
5. Take an algorithm and vary its parameters.  How do changes in the parameters affect the outcomes?

If you have interesting results, feel free to post them as an issue:
```
    https://github.com/econrad003/maze4c/issues
```
# Notes statistics dated 2025-10-10

The runs consisted of producing 100 perfect mazes for each of 14 different maze carving algorithm and 3 fractal tesselation algorithms.  The mazes were all configured on a 36×36 Von Neumann grid (*OblongGrid(36,36)*).

For fractal tessellation, four passes were made starting with a 1×1 trivial maze with each pass tiling alternately with either 3 rows and two columns or 2 rows and 3 columns.  The three algorithms involved simple placement (the trivial or identity group), placement after a random rotation (the rotation group), or placement after a random rotation or reflection (the dihedral group).  The main purpose here is to compare fractal tessellation with other algorithms.

One star (\*) marks the line for Wilson's algorithm which ideally produces a uniformly random spanning tree.  Two stars (\*\*) mark the fractal tessellation lines.

The most noteworthy statistics for the fractal mazes are the standard deviations.  The degree sequences for these mazes show far more variation than the degree sequences for the other algorithms.

## Example

An example of a 36x36 fractal maze with the structure used in the samples, using rotations and reflections, is included as the PNG image file *2025-10-10_maze.png* in the CSV folder. To produce your own sample, I include the Python interpreter statements that I typed to create this sample.  I've added some comments:
```python
from mazes.Algorithms.fractal_tess import FractalTessellation
    # alternating tilings; use dihedral group (rotations and reflections)
    # when the tiles are square, there are 8 symmetries
    # when the tiles are oblong, there are 4 symmetries
tess1=FractalTessellation(3,2,True)
tess2=FractalTessellation(2,3,True)
    # create the maze, 1 pass at a time
maze = tess1.on(passes=1)                   # 1x1 to 3x2
maze = tess2.on(maze, passes=1)             # 3x2 to 6x6
maze = tess1.on(maze, passes=1)             # 6x6 to 18x12
maze = tess2.on(maze, passes=1)             # 18x12 to 36x36
    # the maze is now ready, but it's too big for the console
    # spider graphics (using matplotlib) to the rescue...
from mazes.Graphics.oblong1 import Phocidae
spider = Phocidae(maze)
spider.title("A fractal maze of twisty passages all alike")
spider.draw_maze()
spider.save_maze()                # saves as "maze.png"
spider.show()
```
The maze title is a reference to an old text adventure game from the 1970s known variously as Cave or Adventure.  It was originally written in Fortran -- it has since been ported to computer languages that are devoted to writing text adventures.

The maze has an intricate fractal structure -- there is a lot of symmetry, not only at a given level, but also from level to level.  It also has a boxlike structure that also shows in with recursive division.  As an exercise, find a path from one corner to the diagonally opposite corner.  The SW-NE solution for my maze is included as a separate image.

## Results for Dead Ends (Degree 1 Cells)

```
                        algorithm     mean      std dev
 1                    Prim/Vertex    580.360 ±     7.402
 2                           Prim    394.660 ±     8.394
 3                        Kruskal    393.760 ±     8.391
 4            Fractal Tess/rotate    391.660 ±   103.550 **
 5                         Wilson    378.870 ±    10.090 *
 6                       Inwinder    374.570 ±     8.132
 7                          Eller    374.540 ±     9.951
 8                  Outward Eller    372.740 ±     8.237
 9             Fractal Tess/ident    372.090 ±    95.075 **
10                      Outwinder    356.750 ±     8.890
11                Prim/Simplified    356.090 ±    10.589
12          Fractal Tess/dihedral    355.340 ±   100.509 **
13                     Sidewinder    354.600 ±    10.668
14             Binary Tree/Simple    325.430 ±     7.828
15                    Hunt & Kill    146.960 ±     7.099
16             Depth-first search    132.670 ±     6.290
17           Breadth-first search     92.840 ±    17.254
```
Noteworthy here is the very high standard deviations for the fractal mazes.

The three fractal maze algorithms (rotate, identity, dihedral) ranked, respectively 4 (above Wilson), 9, and 12 in the 10 October 36×36 mazes, and respectively 6 (below Wilson), 9, and 11 in the 9 October 16×16 sample. Tabulating these observations:
```
9 Oct  10 Oct  (2025)
16×16   36×36
    6       4          Fractal Tess/rotate
    5       5          Wilson (baseline)
    9       9          Fractal Tess/ident
   11      12          Fractal Tess/dihedral
```
By rank *order*, I mean the order of just these four samples when sorted from lowest rank to highest rank.  The bottom two entries in the same *order* among the four -- third and fourth.  The top two changed order -- Wilson was the first of the four in the 9 October sample and the second of the four on the 10 October sample.


The standard deviations for the fractal mazes jumped up from about 20\% of the mean in the 9 October samples to about 25\% in the 10 October sample.

### Technical notes

#### Dihedral, identity, rotate

"Dihedral" refers to the dihedral group - admitting rotations and reflections.  "Rotate" refers to the the rotation group which does not admit reflections.  "Identity" refers to the identity group (or trivial group) which does not admit any transformations except the identity.

```     + B +       reflect     + D +       reflect         + D +
        A   C  ->   thru AC >   A   C  ->   thru BD  ->     C   A
        + D +                   + B +                       + B +

          |                                                   |
          +------------------   rotate  ----------------------+
                                180 degrees
```
The totality of reflections does not form a group as (1) we count the identity transformation as a rotation (through 0 degrees -- or, equivalenntly, any multiple of 360 degrees); and (2), the product of any two reflections is a rotation.  For example, as illustrated above, the product of a vertical reflection and a horizontal reflection is a 180 degree rotation.  (Note that the passage labels in the first and third squares are clockwise, but counterclockwise (or anticlockwise) in the middle square.

#### The importance of Wilson's algorithm

As our implementation of Wilson's algorithm is as close as we can get to producing a uniformly random sequence of mazes of a given type, we use it as a baseline.

## Results for Degree 2 Cells (I-Junctions and Corners)

```
                        algorithm     mean      std dev
 1           Breadth-first search   1114.970 ±    34.020
 2             Depth-first search   1034.490 ±    12.672
 3                    Hunt & Kill   1008.110 ±    13.717
 4             Binary Tree/Simple    647.140 ±    15.657
 5                     Sidewinder    621.750 ±    20.238
 6                Prim/Simplified    620.000 ±    19.317
 7          Fractal Tess/dihedral    619.420 ±   182.391 **
 8                      Outwinder    612.500 ±    16.432
 9                  Outward Eller    593.270 ±    15.704
10             Fractal Tess/ident    592.360 ±   167.909 **
11                          Eller    591.740 ±    18.870
12                       Inwinder    590.120 ±    15.206
13                         Wilson    584.070 ±    18.211 *
14            Fractal Tess/rotate    565.230 ±   176.735 **
15                        Kruskal    561.020 ±    14.599
16                           Prim    558.460 ±    16.230
17                    Prim/Vertex    279.110 ±    12.385
```
Again note the very high standard deviations for the fractal mazes.

As with the degree 1 cells, the standard deviation as a percentage of its respective mean increased for fractal mazes from the smaller mazes on 9 October to the larger ones on 10 October.  (The percentage seems to have decreased for the other algorithms.

Comparing the ranks of the four starred algorithms:
```
9 Oct  10 Oct  (2025)
16×16   36×36
    6       7          Fractal Tess/dihedral
   10      10          Fractal Tess/ident
   13      13          Wilson (baseline)
   12      14          Fractal Tess/rotate
```
The rank *order* of the bottom two was different.


## Results for Degree 3 Cells (T-Junctions)

```
                        algorithm     mean      std dev
 1             Binary Tree/Simple    323.430 ±     7.828
 2                      Outwinder    298.750 ±     9.828
 3                    Prim/Vertex    294.700 ±    12.000
 4                           Prim    293.100 ±    11.962
 5             Fractal Tess/ident    293.010 ±    71.000 **
 6                        Kruskal    290.680 ±    10.463
 7                       Inwinder    290.050 ±    11.225
 8                         Wilson    289.250 ±    10.625 *
 9                  Outward Eller    289.240 ±    10.974
10          Fractal Tess/dihedral    289.140 ±    80.484 **
11            Fractal Tess/rotate    288.560 ±    74.815 **
12                          Eller    286.900 ±    13.110
13                     Sidewinder    286.700 ±    11.874
14                Prim/Simplified    285.730 ±    11.226
15                    Hunt & Kill    136.900 ±     6.790
16             Depth-first search    127.010 ±     6.869
17           Breadth-first search     85.540 ±    16.406
```
Note the somewhat high standard deviations for the fractal mazes.

Comparing the ranks of the four starred algorithms:
```
9 Oct  10 Oct  (2025)
16×16   36×36
    9       5          Fractal Tess/ident
    8       8          Wilson (baseline)
   10      10          Fractal Tess/dihedral
   11      11          Fractal Tess/rotate
```
The rank *order* of the top two was different.

### Technical details

A simple calculation shows that the maximum number of degree 3 cells in a perfect maze (*i.e.* a spanning tree) must be less than half the number of cells.  First, assume the number of cells is even (say: n=2k), and the number of degree 3 cells is greater than or equal to k.  Since a perfect maze is connected, the remaining cells must have degree at least 1.  Then
```
     Number of degree 3 cells           j ≥ k
     Number of remaining cells        n-j

     Degree sum:                        S ≥ 3j + n - j
                                          = n + 2j
                                          ≥ n + 2k = n + n = 2n

    Number of passages = 1/2 the degree sum
                                        e ≥ n > n-1
    Number of passages in a tree = n-1
```

For the odd case, let n=2k+1.  At least half would mean j≥k+1, but let's do one better:
```
     Number of degree 3 cells           j ≥ k
     Number of remaining cells        n-j

     Degree sum:                        S ≥ 3j + n - j
                                          = n + 2j
                                          ≥ n + 2k = 2n - 1

    But the degree sum must be even. (Otherwise the number of passages would
    not be an integer.)  So in fact:
                                        S ≥ 2n
    The rest is the same:
    Number of passages = 1/2 the degree sum
                                        e ≥ n > n-1
    Number of passages in a tree = n-1
```

If half or more of the cells (rounding down in the odd case) in a maze are of degree 3 (or more), then the maze is not a tree.  (It is either disconnected or it has a circuit.)

Incidentally, I tried constructing a 4 by 5 tree with as many degree 3 cells as possible.  I first came up with the following simple binary tree:
```
        +---+---+---+---+---+
        | 2   3   3   3   2 |     Cells:  4 × 5 = 20
        +   +   +   +   +   +  Passages: 20 - 1 = 19  perfect maze
        | 1 | 1 | 1 | 1 | 2 |
        +---+---+---+---+   +   Degree 3  7 cells   7 × 3 = 21
        | 2   3   3   3   3 |   Degree 2  4 cells   4 × 2 =  8
        +   +   +   +   +   +   Degree 1  9 cells   9 × 1 =  9
        | 1 | 1 | 1 | 1 | 1 |   Sum: 21 + 8 + 9 = 38 = 2 × 19
        +---+---+---+---+---+
```
We can improve on this with another simple binary tree by moving one passage:
```
        +---+---+---+---+---+
        | 1   3   3   3   2 |     Cells:  4 × 5 = 20
        +---+   +   +   +   +  Passages: 20 - 1 = 19  perfect maze
        | 1 | 1 | 1 | 1 | 2 |
        +   +---+---+---+   +   Degree 3  8 cells   8 × 3 = 24
        | 3   3   3   3   3 |   Degree 2  4 cells   2 × 2 =  4
        +   +   +   +   +   +   Degree 1  9 cells  10 × 1 = 10
        | 1 | 1 | 1 | 1 | 1 |   Sum: 24 + 4 + 10 = 38 = 2 × 19
        +---+---+---+---+---+
```
By extending this example, one can show that, for any positive integer k and any rectangular grid with at least two rows and two columns, and n=2k cells, there is a simple binary tree maze with k-2 degree-3 cells, two degree-2 cells and k degree-1 cells.

That leaves three questions:

1. Are there perfect rectangular mazes with n=2k cells that have k-1 degree-3 cells and k+1 degree-1 cells?
2. What about the odd case, that is, n=2k+1?  The drawings above don't work if we add or remove just one row to make the maze odd.
3. What about a rectangular maze with just one row or just one column?

Question #3 is easy.  Start by sketching a row grid (*i.e.* a grid with exactly one row) with four or five cells.  How many ways can passages of degree 3 be carved on that grid?  How many perfect mazes can be constructed on that grid?


## Results for Degree 4 Cells (Plus-Junctions)

```
                        algorithm     mean      std dev
 1                    Prim/Vertex    141.830 ±     7.188
 2            Fractal Tess/rotate     50.550 ±    46.653 **
 3                        Kruskal     50.540 ±     5.987
 4                           Prim     49.780 ±     5.509
 5                         Wilson     43.810 ±     5.375 *
 6                          Eller     42.820 ±     6.134
 7                       Inwinder     41.260 ±     5.572
 8                  Outward Eller     40.750 ±     5.078
 9             Fractal Tess/ident     38.540 ±    36.357 **
10                Prim/Simplified     34.180 ±     5.454
11                     Sidewinder     32.950 ±     4.926
12          Fractal Tess/dihedral     32.100 ±    34.241 **
13                      Outwinder     28.000 ±     4.607
14                    Hunt & Kill      4.030 ±     1.746
15           Breadth-first search      2.650 ±     1.276
16             Depth-first search      1.830 ±     1.327
17             Binary Tree/Simple      0.000 ±     0.000
```
Relatively speaking, the standard deviations for the fractal mazes are very high, and also suggest that about 2/3 of the sample ranges from 0 to about double the average number of plus-junctions.

Comparing the ranks of the four starred algorithms:
```
9 Oct  10 Oct  (2025)
16×16   36×36
    6       2          Fractal Tess/rotate
    5       5          Wilson (baseline)
   10       9          Fractal Tess/ident
    9      12          Fractal Tess/dihedral
```
The rank *order* of the top two and the rank *order* of the bottom two were both different.


## Results for Diameter (Longest Path Length)

```
                        algorithm     mean      std dev
 1             Depth-first search    633.860 ±    73.589
 2                    Hunt & Kill    300.780 ±    51.198
 3                  Outward Eller    245.290 ±    22.641
 4          Fractal Tess/dihedral    221.340 ±    59.656 **
 5            Fractal Tess/rotate    216.620 ±    50.503 **
 6             Fractal Tess/ident    206.150 ±    38.953 **
 7                         Wilson    197.680 ±    33.894 *
 8                          Eller    186.770 ±    20.350
 9                           Prim    173.830 ±    24.561
10                      Outwinder    173.800 ±     8.323
11                        Kruskal    169.990 ±    28.225
12                     Sidewinder    157.390 ±     8.959
13                    Prim/Vertex    146.640 ±    21.513
14             Binary Tree/Simple    133.660 ±     3.729
15                Prim/Simplified    105.820 ±    14.200
16           Breadth-first search     90.960 ±     9.077
17                       Inwinder     86.190 ±     4.498
```
The standard deviations don't stand out as much here.

```
9 Oct  10 Oct  (2025)
16×16   36×36
    6       4          Fractal Tess/dihedral
    5       5          Fractal Tess/rotate
    4       6          Fractal Tess/ident
    8       7          Wilson (baseline)
```
Regarding rank *order* among the four "rotate" and Wilson were, respectively, second and fourth.  "Dihedral" and "ident switched places, with "dihedral" taking first place among the four in the run which created the larger maze.

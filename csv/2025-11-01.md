# Twistiness comparison

Consider the six degree-2 cell configurations in a Von Neumann neighborhood:
```
 ------ Straight ------    -------- Turns -------

     N            N            N            N
   +   +        +---+        +   +        +   +
 W | X | E    W   X   E    W | X   E    W     | E
   +   +        +---+        +---+        +---+
     S            S            S            S

    (1)          (2)          (3)          (4)


                               N            N
                             +---+        +---+
                           W | X   E    W   X | E
                             +   +        +   +
                               S            S

                              (5)          (6)
```
Four of these configurations (#3 through #6) involve a turn.  The other two are straight, one (#1) vertical and the other (#2) horizontal.

In this experiment, we applied each of several perfect maze algorithms 100 times to 39×39 Von Neumann grids.  The default options were used in each case.  Each maze had 39² = 1521 cells and 1520 bidirectional passages.

The data was collected in the following file: *csv/2025-11-01.csv*

## Turns

A maze with a lot of turns could be considered as "twisty".  We accordingly extract the turns from the CSV and sort the result.

```
$ python
Python 3.10.12
>>> import stats.sort_csv as sorter
>>> filename = "csv/2025-11-01.csv"
>>> g = sorter.group_csv(filename, 1, 2)
>>> result = sorter.extract_columns(g, 0, 2)
>>> result = sorter.sort_selection(result, float, ascending=False)
>>> for i in result:
...     print(g[i][0][0], g[i][0][2], g[i][1][2])   # turns
...
```

Here are the results:
```
             (1)                 (2)    (3)
-------- ALGORITHM ---------    TURNS STD-DEV
hunt and kill                   764.3   18.5
depth-first search              741.7   21.4
2-pump watershed division       478.4   20.5
3-pump watershed division       468.7   18.2
recursive division              450.1   22.9
Wilson's algorithm              428.0   16.3  **
reverse Aldous/Broder           422.4   18.7  **
Aldous/Broder                   421.5   17.4  **
Houston's algorithm             417.1   15.2
2-thread random walk            415.4   18.0
3-thread random walk            412.1   16.9
Kruskal's algorithm             409.3   15.9
outward Eller                   390.4   19.3
Eller's algorithm               385.0   16.1
sidewinder                      372.7   17.6
inwinder                        371.0   16.7
simple binary tree              360.8   15.7
outwinder                       346.4   13.4
simple Prim                     319.9   17.6
breadth-first search              3.8    0.5
```

Column (2) is the smaple mean for the number of turns.  Column (3) is the sample standard deviation.

The hunt and kill algorithm had the highest average number of turns -- on average, 50.2% of the cells in each hunt and kill maze were turns.  DFS was a close second with 48.8% of cells -- a bit over one standard deviation away.

For the uniform algorithms (Aldous/Broder, reverse Aldous/Broder, and Wilson, respectively), 27.7%, 27.8%, and 28.1% of cells were turns.  The results for all three were well within one half of a standard deviation of one another.

BFS was the least twisty algorithm with about one fourth of a percent of cells.

Second from bottom was simplified Prim with about 21% of cases.

## Degree 2, N/S

A maze with a lot of N/S degree-2 cells has a north-south or vertical bias.  Continuing the analytic code:
```
>>> result = sorter.extract_columns(g, 0, 3)
>>> result = sorter.sort_selection(result, float, ascending=False)
>>> for i in result:
...     print(g[i][0][0], g[i][0][3], g[i][1][3])   # N/S
...
```

And the results:
```
             (1)                 (2)    (3)
-------- ALGORITHM ---------     N/S  STD-DEV
breadth-first search            687.3  190.2
depth-first search              237.3   19.7
Eller's algorithm               220.5   14.0
hunt and kill                   209.6   17.4
recursive division              207.8   19.0
simple Prim                     203.6   32.5
simple binary tree              198.1   19.0
outwinder                       184.3   15.4
sidewinder                      163.2   15.5
inwinder                        160.2   17.8
outward Eller                   152.8   15.2
reverse Aldous/Broder           133.3   12.0  **
Aldous/Broder                   132.8   13.4  **
Wilson's algorithm              131.7   11.0  **
3-pump watershed division       131.4   17.0
2-pump watershed division       130.3   16.8
Houston's algorithm             129.2   13.3
2-thread random walk            128.7   12.4
3-thread random walk            125.6   11.6
Kruskal's algorithm             123.4   11.9
```

The obvious winner fora N/S bias is breadth-first search (45.2% of cells).  DFS is a distant second (15.6%).

Means for the uniform algorithms varied from 8.7% to 8.8%, with standard deviations of slightly under 1%.

Kruskal's algorithm placed last with a mean of 8.1%, but the multithreaded random walks were fairly close.

## Degree 2, E/W

A maze with a lot of E/W degree-2 cells has a east-west or horizontal bias.  It is worth noting algorithms where the vertical means and horizontal means are significantly different.  As above:
```
>>> result = sorter.extract_columns(g, 0, 4)
>>> result = sorter.sort_selection(result, float, ascending=False)
>>> for i in result:
...     print(g[i][0][0], g[i][0][4], g[i][1][4])   # E/W
...
```

The results:
```
             (1)                 (2)    (3)
-------- ALGORITHM ---------     E/W  STD-DEV
breadth-first search            637.4  185.3
depth-first search              238.0   21.2
hunt and kill                   211.8   18.2
simple binary tree              200.7   17.8
simple Prim                     195.9   30.8
outwinder                       185.4   12.4
inwinder                        165.6   14.5
sidewinder                      163.0   15.5
outward Eller                   151.8   14.9
reverse Aldous/Broder           134.3   12.5  **
3-pump watershed division       134.2   17.6
Houston's algorithm             132.4   13.4
Wilson's algorithm              131.7   11.6  **
Aldous/Broder                   131.4   13.5  **
3-thread random walk            129.3   13.0
2-pump watershed division       129.1   16.2
2-thread random walk            127.3   11.5
Kruskal's algorithm             124.2   12.2
recursive division               87.5   18.5      ***
Eller's algorithm                86.6   10.9      ***
```

BFS and DFS placed first and second, respectively.  Taking the means and standard deviations into account, the horizontal and vertical bias for both is about the same.

Means for the uniform algorithms were about the same as for the vertical case.

Noteworthy changes in horizontal *vs* vertical placement occurred for recursive division and Eller's algorithm.  In the case of recursive division, the first division for a 39×39 maze is horizontal.  Eller's algorithm handles horizontal and vertical connections in a very asymmetric manner.  (Unlike standard Eller, outward Eller does not have a horizontal/vertical asymmetry.)

With the exceptions of recursive division and standard Eller, results for the horizontal and the vertical degree-2 cells are quite similar.

## Other results

In addition to the breakdown of degree-2 cells, the remaining cells were classified by degree.  I have not checked whether results for these cells are consistent with the results of the October 2025 experiments.